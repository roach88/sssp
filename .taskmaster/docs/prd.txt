# Product Requirements Document: Advanced Directed SSSP Algorithm Library

## Product Overview

### Project Name
Advanced Directed SSSP Algorithm Library

### Version
1.0

### Purpose
Implement a custom library for solving the Single-Source Shortest Paths (SSSP) problem on directed graphs using a novel O(m log^(2/3) n) deterministic algorithm. The library provides faster context retrieval and reduced latency for applications requiring SSSP calculations, particularly for GraphRAG databases.

### Key Innovation
The implementation leverages the BMSSP (Bounded Multi-Source Shortest Path) procedure, which operates as a recursive divide-and-conquer algorithm combining ideas from Dijkstra's and Bellman-Ford algorithms to break the Θ(n log n) sorting bottleneck.

## Core Requirements

### Algorithm Implementation

1. **BMSSP Recursive Procedure (Algorithm 3)**
   - Main recursive divide-and-conquer algorithm
   - Manages recursion levels from 0 to ⌈(log n)/t⌉
   - Handles boundary conditions and vertex completeness
   - Integrates with specialized data structure D for efficient frontier management

2. **FindPivots Procedure (Algorithm 1)**
   - Implements frontier reduction to minimize vertex set
   - Performs k-step relaxation similar to Bellman-Ford
   - Constructs directed forest for pivot identification
   - Maintains O(min{k²|S|, k|Ũ|}) time complexity

3. **BaseCase Procedure (Algorithm 2)**
   - Acts as mini-Dijkstra's algorithm at recursion level 0
   - Uses binary heap for efficient vertex extraction
   - Handles singleton source sets
   - Maintains C|U| log k time complexity

### Data Structure Requirements

1. **Specialized Block-Based Data Structure (Lemma 3.3)**
   - Adaptive linked list structure for frontier management
   - Supports Initialize, Insert, Batch Prepend, and Pull operations
   - Maintains two sequences (D0 for batch prepends, D1 for inserts)
   - Uses self-balancing BST for block upper bound management
   - Implements split operations for block size management

2. **Binary Heap**
   - Used in BaseCase for Dijkstra-like operations
   - Supports ExtractMin, Insert, and DecreaseKey operations

### Graph Processing Requirements

1. **Graph Representation**
   - Handle directed graphs G = (V, E)
   - Support real non-negative edge weights
   - Operate within comparison-addition model

2. **Constant-Degree Transformation**
   - Transform arbitrary graphs to constant in/out-degree
   - Implement zero-weight cycle substitution
   - Preserve shortest paths in transformed graph
   - Result in O(m) vertices and edges with max degree 2

3. **Tie-Breaking Mechanism**
   - Establish total order for paths with equal lengths
   - Implement lexicographic comparison using path tuples
   - Support O(1) time path comparisons

### API Requirements

1. **Core API Function**
   ```cpp
   std::pair<std::map<Vertex, double>, std::map<Vertex, Vertex>>
   solveSSSP(Graph* graph, Vertex source);
   ```
   - Return shortest distances from source
   - Return predecessor map for path reconstruction
   - Handle invalid inputs gracefully

2. **Supporting APIs**
   - Graph transformation utilities
   - Path reconstruction functions
   - Distance query interfaces
   - Debug and visualization tools

### Performance Requirements

1. **Time Complexity**
   - Overall: O(m log^(2/3) n) deterministic time
   - Parameters: k = ⌊log^(1/3)(n)⌋, t = ⌊log^(2/3)(n)⌋
   - Maintain efficient constant factors

2. **Space Complexity**
   - Efficient memory usage for recursive calls
   - Optimized data structure storage
   - Handle large graphs without excessive memory consumption

### Quality Requirements

1. **Correctness**
   - Maintain disjoint Ui sets across recursive calls
   - Ensure edge relaxation conditions
   - Guarantee completeness propagation
   - Pass comprehensive test suites

2. **Robustness**
   - Handle disconnected components
   - Manage floating-point precision issues
   - Provide error handling for invalid inputs
   - Support various graph densities and weight distributions

3. **Maintainability**
   - Clean, well-documented code
   - Modular architecture
   - Comprehensive logging and debugging support
   - Clear separation of concerns

## Development Priorities

### Phase 1: Core Algorithm Implementation
1. Implement basic graph representation and transformation
2. Develop specialized data structure D
3. Implement BaseCase procedure
4. Implement FindPivots procedure
5. Implement main BMSSP recursive procedure

### Phase 2: Optimization and Testing
1. Optimize critical inner loops
2. Implement comprehensive test suite
3. Profile and tune performance
4. Add debug and visualization tools

### Phase 3: API and Integration
1. Design and implement public API
2. Add path reconstruction utilities
3. Create documentation and examples
4. Package for distribution

## Success Metrics

1. **Performance**: Achieve O(m log^(2/3) n) time complexity with good constant factors
2. **Correctness**: Pass all test cases including edge cases
3. **Usability**: Clean API that's easy to integrate
4. **Reliability**: Handle various graph types without crashes or incorrect results
5. **Documentation**: Complete API documentation with usage examples

## Technical Constraints

1. **Language**: C++ for performance-critical implementation
2. **Dependencies**: Minimize external dependencies
3. **Platform**: Cross-platform compatibility (Linux, macOS, Windows)
4. **Standards**: C++17 or later for modern language features

## Testing Requirements

1. **Unit Tests**: Cover all individual components
2. **Integration Tests**: Test complete algorithm flow
3. **Performance Tests**: Verify complexity bounds
4. **Edge Cases**: Handle disconnected graphs, single vertices, dense/sparse graphs
5. **Comparison Tests**: Validate against standard Dijkstra implementation

## Documentation Requirements

1. **API Documentation**: Complete function and class documentation
2. **Algorithm Documentation**: Explain theoretical foundations
3. **Usage Examples**: Provide sample code for common use cases
4. **Performance Guide**: Document optimization tips and benchmarks
5. **Build Instructions**: Clear setup and compilation instructions